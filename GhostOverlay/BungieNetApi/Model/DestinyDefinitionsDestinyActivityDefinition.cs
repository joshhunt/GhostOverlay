/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.8.0
 * Contact: support@bungie.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = BungieNetApi.Client.OpenAPIDateConverter;

namespace BungieNetApi.Model
{
    /// <summary>
    /// The static data about Activities in Destiny 2.  Note that an Activity must be combined with an ActivityMode to know - from a Gameplay perspective - what the user is \&quot;Playing\&quot;.  In most PvE activities, this is fairly straightforward. A Story Activity can only be played in the Story Activity Mode.  However, in PvP activities, the Activity alone only tells you the map being played, or the Playlist that the user chose to enter. You&#39;ll need to know the Activity Mode they&#39;re playing to know that they&#39;re playing Mode X on Map Y.  Activity Definitions tell a great deal of information about what *could* be relevant to a user: what rewards they can earn, what challenges could be performed, what modifiers could be applied. To figure out which of these properties is actually live, you&#39;ll need to combine the definition with \&quot;Live\&quot; data from one of the Destiny endpoints.  Activities also have Activity Types, but unfortunately in Destiny 2 these are even less reliable of a source of information than they were in Destiny 1. I will be looking into ways to provide more reliable sources for type information as time goes on, but for now we&#39;re going to have to deal with the limitations. See DestinyActivityTypeDefinition for more information.
    /// </summary>
    [DataContract]
    public partial class DestinyDefinitionsDestinyActivityDefinition :  IEquatable<DestinyDefinitionsDestinyActivityDefinition>, IValidatableObject
    {
        /// <summary>
        /// If the activity had an activity mode directly defined on it, this will be the enum value of that mode.
        /// </summary>
        /// <value>If the activity had an activity mode directly defined on it, this will be the enum value of that mode.</value>
        public enum DirectActivityModeTypeEnum
        {
            /// <summary>
            /// Enum NUMBER_0 for value: 0
            /// </summary>
            NUMBER_0 = 0,

            /// <summary>
            /// Enum NUMBER_2 for value: 2
            /// </summary>
            NUMBER_2 = 2,

            /// <summary>
            /// Enum NUMBER_3 for value: 3
            /// </summary>
            NUMBER_3 = 3,

            /// <summary>
            /// Enum NUMBER_4 for value: 4
            /// </summary>
            NUMBER_4 = 4,

            /// <summary>
            /// Enum NUMBER_5 for value: 5
            /// </summary>
            NUMBER_5 = 5,

            /// <summary>
            /// Enum NUMBER_6 for value: 6
            /// </summary>
            NUMBER_6 = 6,

            /// <summary>
            /// Enum NUMBER_7 for value: 7
            /// </summary>
            NUMBER_7 = 7,

            /// <summary>
            /// Enum NUMBER_9 for value: 9
            /// </summary>
            NUMBER_9 = 9,

            /// <summary>
            /// Enum NUMBER_10 for value: 10
            /// </summary>
            NUMBER_10 = 10,

            /// <summary>
            /// Enum NUMBER_11 for value: 11
            /// </summary>
            NUMBER_11 = 11,

            /// <summary>
            /// Enum NUMBER_12 for value: 12
            /// </summary>
            NUMBER_12 = 12,

            /// <summary>
            /// Enum NUMBER_13 for value: 13
            /// </summary>
            NUMBER_13 = 13,

            /// <summary>
            /// Enum NUMBER_15 for value: 15
            /// </summary>
            NUMBER_15 = 15,

            /// <summary>
            /// Enum NUMBER_16 for value: 16
            /// </summary>
            NUMBER_16 = 16,

            /// <summary>
            /// Enum NUMBER_17 for value: 17
            /// </summary>
            NUMBER_17 = 17,

            /// <summary>
            /// Enum NUMBER_18 for value: 18
            /// </summary>
            NUMBER_18 = 18,

            /// <summary>
            /// Enum NUMBER_19 for value: 19
            /// </summary>
            NUMBER_19 = 19,

            /// <summary>
            /// Enum NUMBER_20 for value: 20
            /// </summary>
            NUMBER_20 = 20,

            /// <summary>
            /// Enum NUMBER_21 for value: 21
            /// </summary>
            NUMBER_21 = 21,

            /// <summary>
            /// Enum NUMBER_22 for value: 22
            /// </summary>
            NUMBER_22 = 22,

            /// <summary>
            /// Enum NUMBER_24 for value: 24
            /// </summary>
            NUMBER_24 = 24,

            /// <summary>
            /// Enum NUMBER_25 for value: 25
            /// </summary>
            NUMBER_25 = 25,

            /// <summary>
            /// Enum NUMBER_26 for value: 26
            /// </summary>
            NUMBER_26 = 26,

            /// <summary>
            /// Enum NUMBER_27 for value: 27
            /// </summary>
            NUMBER_27 = 27,

            /// <summary>
            /// Enum NUMBER_28 for value: 28
            /// </summary>
            NUMBER_28 = 28,

            /// <summary>
            /// Enum NUMBER_29 for value: 29
            /// </summary>
            NUMBER_29 = 29,

            /// <summary>
            /// Enum NUMBER_30 for value: 30
            /// </summary>
            NUMBER_30 = 30,

            /// <summary>
            /// Enum NUMBER_31 for value: 31
            /// </summary>
            NUMBER_31 = 31,

            /// <summary>
            /// Enum NUMBER_32 for value: 32
            /// </summary>
            NUMBER_32 = 32,

            /// <summary>
            /// Enum NUMBER_37 for value: 37
            /// </summary>
            NUMBER_37 = 37,

            /// <summary>
            /// Enum NUMBER_38 for value: 38
            /// </summary>
            NUMBER_38 = 38,

            /// <summary>
            /// Enum NUMBER_39 for value: 39
            /// </summary>
            NUMBER_39 = 39,

            /// <summary>
            /// Enum NUMBER_40 for value: 40
            /// </summary>
            NUMBER_40 = 40,

            /// <summary>
            /// Enum NUMBER_41 for value: 41
            /// </summary>
            NUMBER_41 = 41,

            /// <summary>
            /// Enum NUMBER_42 for value: 42
            /// </summary>
            NUMBER_42 = 42,

            /// <summary>
            /// Enum NUMBER_43 for value: 43
            /// </summary>
            NUMBER_43 = 43,

            /// <summary>
            /// Enum NUMBER_44 for value: 44
            /// </summary>
            NUMBER_44 = 44,

            /// <summary>
            /// Enum NUMBER_45 for value: 45
            /// </summary>
            NUMBER_45 = 45,

            /// <summary>
            /// Enum NUMBER_46 for value: 46
            /// </summary>
            NUMBER_46 = 46,

            /// <summary>
            /// Enum NUMBER_47 for value: 47
            /// </summary>
            NUMBER_47 = 47,

            /// <summary>
            /// Enum NUMBER_48 for value: 48
            /// </summary>
            NUMBER_48 = 48,

            /// <summary>
            /// Enum NUMBER_49 for value: 49
            /// </summary>
            NUMBER_49 = 49,

            /// <summary>
            /// Enum NUMBER_50 for value: 50
            /// </summary>
            NUMBER_50 = 50,

            /// <summary>
            /// Enum NUMBER_51 for value: 51
            /// </summary>
            NUMBER_51 = 51,

            /// <summary>
            /// Enum NUMBER_52 for value: 52
            /// </summary>
            NUMBER_52 = 52,

            /// <summary>
            /// Enum NUMBER_53 for value: 53
            /// </summary>
            NUMBER_53 = 53,

            /// <summary>
            /// Enum NUMBER_54 for value: 54
            /// </summary>
            NUMBER_54 = 54,

            /// <summary>
            /// Enum NUMBER_55 for value: 55
            /// </summary>
            NUMBER_55 = 55,

            /// <summary>
            /// Enum NUMBER_56 for value: 56
            /// </summary>
            NUMBER_56 = 56,

            /// <summary>
            /// Enum NUMBER_57 for value: 57
            /// </summary>
            NUMBER_57 = 57,

            /// <summary>
            /// Enum NUMBER_58 for value: 58
            /// </summary>
            NUMBER_58 = 58,

            /// <summary>
            /// Enum NUMBER_59 for value: 59
            /// </summary>
            NUMBER_59 = 59,

            /// <summary>
            /// Enum NUMBER_60 for value: 60
            /// </summary>
            NUMBER_60 = 60,

            /// <summary>
            /// Enum NUMBER_61 for value: 61
            /// </summary>
            NUMBER_61 = 61,

            /// <summary>
            /// Enum NUMBER_62 for value: 62
            /// </summary>
            NUMBER_62 = 62,

            /// <summary>
            /// Enum NUMBER_63 for value: 63
            /// </summary>
            NUMBER_63 = 63,

            /// <summary>
            /// Enum NUMBER_64 for value: 64
            /// </summary>
            NUMBER_64 = 64,

            /// <summary>
            /// Enum NUMBER_65 for value: 65
            /// </summary>
            NUMBER_65 = 65,

            /// <summary>
            /// Enum NUMBER_66 for value: 66
            /// </summary>
            NUMBER_66 = 66,

            /// <summary>
            /// Enum NUMBER_67 for value: 67
            /// </summary>
            NUMBER_67 = 67,

            /// <summary>
            /// Enum NUMBER_68 for value: 68
            /// </summary>
            NUMBER_68 = 68,

            /// <summary>
            /// Enum NUMBER_69 for value: 69
            /// </summary>
            NUMBER_69 = 69,

            /// <summary>
            /// Enum NUMBER_70 for value: 70
            /// </summary>
            NUMBER_70 = 70,

            /// <summary>
            /// Enum NUMBER_71 for value: 71
            /// </summary>
            NUMBER_71 = 71,

            /// <summary>
            /// Enum NUMBER_72 for value: 72
            /// </summary>
            NUMBER_72 = 72,

            /// <summary>
            /// Enum NUMBER_73 for value: 73
            /// </summary>
            NUMBER_73 = 73,

            /// <summary>
            /// Enum NUMBER_74 for value: 74
            /// </summary>
            NUMBER_74 = 74,

            /// <summary>
            /// Enum NUMBER_75 for value: 75
            /// </summary>
            NUMBER_75 = 75,

            /// <summary>
            /// Enum NUMBER_76 for value: 76
            /// </summary>
            NUMBER_76 = 76,

            /// <summary>
            /// Enum NUMBER_77 for value: 77
            /// </summary>
            NUMBER_77 = 77,

            /// <summary>
            /// Enum NUMBER_78 for value: 78
            /// </summary>
            NUMBER_78 = 78,

            /// <summary>
            /// Enum NUMBER_79 for value: 79
            /// </summary>
            NUMBER_79 = 79,

            /// <summary>
            /// Enum NUMBER_80 for value: 80
            /// </summary>
            NUMBER_80 = 80,

            /// <summary>
            /// Enum NUMBER_81 for value: 81
            /// </summary>
            NUMBER_81 = 81,

            /// <summary>
            /// Enum NUMBER_82 for value: 82
            /// </summary>
            NUMBER_82 = 82,

            /// <summary>
            /// Enum NUMBER_83 for value: 83
            /// </summary>
            NUMBER_83 = 83,

            /// <summary>
            /// Enum NUMBER_84 for value: 84
            /// </summary>
            NUMBER_84 = 84

        }

        /// <summary>
        /// If the activity had an activity mode directly defined on it, this will be the enum value of that mode.
        /// </summary>
        /// <value>If the activity had an activity mode directly defined on it, this will be the enum value of that mode.</value>
        [DataMember(Name="directActivityModeType", EmitDefaultValue=false)]
        public DirectActivityModeTypeEnum? DirectActivityModeType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="DestinyDefinitionsDestinyActivityDefinition" /> class.
        /// </summary>
        /// <param name="displayProperties">The title, subtitle, and icon for the activity. We do a little post-processing on this to try and account for Activities where the designers have left this data too minimal to determine what activity is actually being played..</param>
        /// <param name="originalDisplayProperties">The unadulterated form of the display properties, as they ought to be shown in the Director (if the activity appears in the director)..</param>
        /// <param name="selectionScreenDisplayProperties">The title, subtitle, and icon for the activity as determined by Selection Screen data, if there is any for this activity. There won&#39;t be data in this field if the activity is never shown in a selection/options screen..</param>
        /// <param name="releaseIcon">If the activity has an icon associated with a specific release (such as a DLC), this is the path to that release&#39;s icon..</param>
        /// <param name="releaseTime">If the activity will not be visible until a specific and known time, this will be the seconds since the Epoch when it will become visible..</param>
        /// <param name="activityLevel">The difficulty level of the activity..</param>
        /// <param name="activityLightLevel">The recommended light level for this activity..</param>
        /// <param name="destinationHash">The hash identifier for the Destination on which this Activity is played. Use it to look up the DestinyDestinationDefinition for human readable info about the destination. A Destination can be thought of as a more specific location than a \&quot;Place\&quot;. For instance, if the \&quot;Place\&quot; is Earth, the \&quot;Destination\&quot; would be a specific city or region on Earth..</param>
        /// <param name="placeHash">The hash identifier for the \&quot;Place\&quot; on which this Activity is played. Use it to look up the DestinyPlaceDefinition for human readable info about the Place. A Place is the largest-scoped concept for location information. For instance, if the \&quot;Place\&quot; is Earth, the \&quot;Destination\&quot; would be a specific city or region on Earth..</param>
        /// <param name="activityTypeHash">The hash identifier for the Activity Type of this Activity. You may use it to look up the DestinyActivityTypeDefinition for human readable info, but be forewarned: Playlists and many PVP Map Activities will map to generic Activity Types. You&#39;ll have to use your knowledge of the Activity Mode being played to get more specific information about what the user is playing..</param>
        /// <param name="tier">The difficulty tier of the activity..</param>
        /// <param name="pgcrImage">When Activities are completed, we generate a \&quot;Post-Game Carnage Report\&quot;, or PGCR, with details about what happened in that activity (how many kills someone got, which team won, etc...) We use this image as the background when displaying PGCR information, and often use it when we refer to the Activity in general..</param>
        /// <param name="rewards">The expected possible rewards for the activity. These rewards may or may not be accessible for an individual player based on their character state, the account state, and even the game&#39;s state overall. But it is a useful reference for possible rewards you can earn in the activity. These match up to rewards displayed when you hover over the Activity in the in-game Director, and often refer to Placeholder or \&quot;Dummy\&quot; items: items that tell you what you can earn in vague terms rather than what you&#39;ll specifically be earning (partly because the game doesn&#39;t even know what you&#39;ll earn specifically until you roll for it at the end).</param>
        /// <param name="modifiers">Activities can have Modifiers, as defined in DestinyActivityModifierDefinition. These are references to the modifiers that *can* be applied to that activity, along with data that we use to determine if that modifier is actually active at any given point in time..</param>
        /// <param name="isPlaylist">If True, this Activity is actually a Playlist that refers to multiple possible specific Activities and Activity Modes. For instance, a Crucible Playlist may have references to multiple Activities (Maps) with multiple Activity Modes (specific PvP gameplay modes). If this is true, refer to the playlistItems property for the specific entries in the playlist..</param>
        /// <param name="challenges">An activity can have many Challenges, of which any subset of them may be active for play at any given period of time. This gives the information about the challenges and data that we use to understand when they&#39;re active and what rewards they provide. Sadly, at the moment there&#39;s no central definition for challenges: much like \&quot;Skulls\&quot; were in Destiny 1, these are defined on individual activities and there can be many duplicates/near duplicates across the Destiny 2 ecosystem. I have it in mind to centralize these in a future revision of the API, but we are out of time..</param>
        /// <param name="optionalUnlockStrings">If there are status strings related to the activity and based on internal state of the game, account, or character, then this will be the definition of those strings and the states needed in order for the strings to be shown..</param>
        /// <param name="playlistItems">Represents all of the possible activities that could be played in the Playlist, along with information that we can use to determine if they are active at the present time..</param>
        /// <param name="activityGraphList">Unfortunately, in practice this is almost never populated. In theory, this is supposed to tell which Activity Graph to show if you bring up the director while in this activity..</param>
        /// <param name="matchmaking">This block of data provides information about the Activity&#39;s matchmaking attributes: how many people can join and such..</param>
        /// <param name="guidedGame">This block of data, if it exists, provides information about the guided game experience and restrictions for this activity. If it doesn&#39;t exist, the game is not able to be played as a guided game..</param>
        /// <param name="directActivityModeHash">If this activity had an activity mode directly defined on it, this will be the hash of that mode..</param>
        /// <param name="directActivityModeType">If the activity had an activity mode directly defined on it, this will be the enum value of that mode..</param>
        /// <param name="loadouts">The set of all possible loadout requirements that could be active for this activity. Only one will be active at any given time, and you can discover which one through activity-associated data such as Milestones that have activity info on them..</param>
        /// <param name="activityModeHashes">The hash identifiers for Activity Modes relevant to this activity.  Note that if this is a playlist, the specific playlist entry chosen will determine the actual activity modes that end up being relevant..</param>
        /// <param name="activityModeTypes">The activity modes - if any - in enum form. Because we can&#39;t seem to escape the enums..</param>
        /// <param name="isPvP">If true, this activity is a PVP activity or playlist..</param>
        /// <param name="insertionPoints">The list of phases or points of entry into an activity, along with information we can use to determine their gating and availability..</param>
        /// <param name="activityLocationMappings">A list of location mappings that are affected by this activity. Pulled out of DestinyLocationDefinitions for our/your lookup convenience..</param>
        /// <param name="hash">The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to..</param>
        /// <param name="index">The index of the entity as it was found in the investment tables..</param>
        /// <param name="redacted">If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!.</param>
        public DestinyDefinitionsDestinyActivityDefinition(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties = default(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition), DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition originalDisplayProperties = default(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition), DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition selectionScreenDisplayProperties = default(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition), string releaseIcon = default(string), int releaseTime = default(int), int activityLevel = default(int), int activityLightLevel = default(int), long destinationHash = default(long), long placeHash = default(long), long activityTypeHash = default(long), int tier = default(int), string pgcrImage = default(string), List<DestinyDefinitionsDestinyActivityRewardDefinition> rewards = default(List<DestinyDefinitionsDestinyActivityRewardDefinition>), List<DestinyDefinitionsDestinyActivityModifierReferenceDefinition> modifiers = default(List<DestinyDefinitionsDestinyActivityModifierReferenceDefinition>), bool isPlaylist = default(bool), List<DestinyDefinitionsDestinyActivityChallengeDefinition> challenges = default(List<DestinyDefinitionsDestinyActivityChallengeDefinition>), List<DestinyDefinitionsDestinyActivityUnlockStringDefinition> optionalUnlockStrings = default(List<DestinyDefinitionsDestinyActivityUnlockStringDefinition>), List<DestinyDefinitionsDestinyActivityPlaylistItemDefinition> playlistItems = default(List<DestinyDefinitionsDestinyActivityPlaylistItemDefinition>), List<DestinyDefinitionsDestinyActivityGraphListEntryDefinition> activityGraphList = default(List<DestinyDefinitionsDestinyActivityGraphListEntryDefinition>), DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition matchmaking = default(DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition), DestinyDefinitionsDestinyActivityGuidedBlockDefinition guidedGame = default(DestinyDefinitionsDestinyActivityGuidedBlockDefinition), long directActivityModeHash = default(long), DirectActivityModeTypeEnum? directActivityModeType = default(DirectActivityModeTypeEnum?), List<DestinyDefinitionsDestinyActivityLoadoutRequirementSet> loadouts = default(List<DestinyDefinitionsDestinyActivityLoadoutRequirementSet>), List<long> activityModeHashes = default(List<long>), List<int> activityModeTypes = default(List<int>), bool isPvP = default(bool), List<DestinyDefinitionsDestinyActivityInsertionPointDefinition> insertionPoints = default(List<DestinyDefinitionsDestinyActivityInsertionPointDefinition>), List<DestinyConstantsDestinyEnvironmentLocationMapping> activityLocationMappings = default(List<DestinyConstantsDestinyEnvironmentLocationMapping>), long hash = default(long), int index = default(int), bool redacted = default(bool))
        {
            this.DisplayProperties = displayProperties;
            this.OriginalDisplayProperties = originalDisplayProperties;
            this.SelectionScreenDisplayProperties = selectionScreenDisplayProperties;
            this.ReleaseIcon = releaseIcon;
            this.ReleaseTime = releaseTime;
            this.ActivityLevel = activityLevel;
            this.ActivityLightLevel = activityLightLevel;
            this.DestinationHash = destinationHash;
            this.PlaceHash = placeHash;
            this.ActivityTypeHash = activityTypeHash;
            this.Tier = tier;
            this.PgcrImage = pgcrImage;
            this.Rewards = rewards;
            this.Modifiers = modifiers;
            this.IsPlaylist = isPlaylist;
            this.Challenges = challenges;
            this.OptionalUnlockStrings = optionalUnlockStrings;
            this.PlaylistItems = playlistItems;
            this.ActivityGraphList = activityGraphList;
            this.Matchmaking = matchmaking;
            this.GuidedGame = guidedGame;
            this.DirectActivityModeHash = directActivityModeHash;
            this.DirectActivityModeType = directActivityModeType;
            this.Loadouts = loadouts;
            this.ActivityModeHashes = activityModeHashes;
            this.ActivityModeTypes = activityModeTypes;
            this.IsPvP = isPvP;
            this.InsertionPoints = insertionPoints;
            this.ActivityLocationMappings = activityLocationMappings;
            this.Hash = hash;
            this.Index = index;
            this.Redacted = redacted;
        }
        
        /// <summary>
        /// The title, subtitle, and icon for the activity. We do a little post-processing on this to try and account for Activities where the designers have left this data too minimal to determine what activity is actually being played.
        /// </summary>
        /// <value>The title, subtitle, and icon for the activity. We do a little post-processing on this to try and account for Activities where the designers have left this data too minimal to determine what activity is actually being played.</value>
        [DataMember(Name="displayProperties", EmitDefaultValue=false)]
        public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition DisplayProperties { get; set; }

        /// <summary>
        /// The unadulterated form of the display properties, as they ought to be shown in the Director (if the activity appears in the director).
        /// </summary>
        /// <value>The unadulterated form of the display properties, as they ought to be shown in the Director (if the activity appears in the director).</value>
        [DataMember(Name="originalDisplayProperties", EmitDefaultValue=false)]
        public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition OriginalDisplayProperties { get; set; }

        /// <summary>
        /// The title, subtitle, and icon for the activity as determined by Selection Screen data, if there is any for this activity. There won&#39;t be data in this field if the activity is never shown in a selection/options screen.
        /// </summary>
        /// <value>The title, subtitle, and icon for the activity as determined by Selection Screen data, if there is any for this activity. There won&#39;t be data in this field if the activity is never shown in a selection/options screen.</value>
        [DataMember(Name="selectionScreenDisplayProperties", EmitDefaultValue=false)]
        public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition SelectionScreenDisplayProperties { get; set; }

        /// <summary>
        /// If the activity has an icon associated with a specific release (such as a DLC), this is the path to that release&#39;s icon.
        /// </summary>
        /// <value>If the activity has an icon associated with a specific release (such as a DLC), this is the path to that release&#39;s icon.</value>
        [DataMember(Name="releaseIcon", EmitDefaultValue=false)]
        public string ReleaseIcon { get; set; }

        /// <summary>
        /// If the activity will not be visible until a specific and known time, this will be the seconds since the Epoch when it will become visible.
        /// </summary>
        /// <value>If the activity will not be visible until a specific and known time, this will be the seconds since the Epoch when it will become visible.</value>
        [DataMember(Name="releaseTime", EmitDefaultValue=false)]
        public int ReleaseTime { get; set; }

        /// <summary>
        /// The difficulty level of the activity.
        /// </summary>
        /// <value>The difficulty level of the activity.</value>
        [DataMember(Name="activityLevel", EmitDefaultValue=false)]
        public int ActivityLevel { get; set; }

        /// <summary>
        /// The recommended light level for this activity.
        /// </summary>
        /// <value>The recommended light level for this activity.</value>
        [DataMember(Name="activityLightLevel", EmitDefaultValue=false)]
        public int ActivityLightLevel { get; set; }

        /// <summary>
        /// The hash identifier for the Destination on which this Activity is played. Use it to look up the DestinyDestinationDefinition for human readable info about the destination. A Destination can be thought of as a more specific location than a \&quot;Place\&quot;. For instance, if the \&quot;Place\&quot; is Earth, the \&quot;Destination\&quot; would be a specific city or region on Earth.
        /// </summary>
        /// <value>The hash identifier for the Destination on which this Activity is played. Use it to look up the DestinyDestinationDefinition for human readable info about the destination. A Destination can be thought of as a more specific location than a \&quot;Place\&quot;. For instance, if the \&quot;Place\&quot; is Earth, the \&quot;Destination\&quot; would be a specific city or region on Earth.</value>
        [DataMember(Name="destinationHash", EmitDefaultValue=false)]
        public long DestinationHash { get; set; }

        /// <summary>
        /// The hash identifier for the \&quot;Place\&quot; on which this Activity is played. Use it to look up the DestinyPlaceDefinition for human readable info about the Place. A Place is the largest-scoped concept for location information. For instance, if the \&quot;Place\&quot; is Earth, the \&quot;Destination\&quot; would be a specific city or region on Earth.
        /// </summary>
        /// <value>The hash identifier for the \&quot;Place\&quot; on which this Activity is played. Use it to look up the DestinyPlaceDefinition for human readable info about the Place. A Place is the largest-scoped concept for location information. For instance, if the \&quot;Place\&quot; is Earth, the \&quot;Destination\&quot; would be a specific city or region on Earth.</value>
        [DataMember(Name="placeHash", EmitDefaultValue=false)]
        public long PlaceHash { get; set; }

        /// <summary>
        /// The hash identifier for the Activity Type of this Activity. You may use it to look up the DestinyActivityTypeDefinition for human readable info, but be forewarned: Playlists and many PVP Map Activities will map to generic Activity Types. You&#39;ll have to use your knowledge of the Activity Mode being played to get more specific information about what the user is playing.
        /// </summary>
        /// <value>The hash identifier for the Activity Type of this Activity. You may use it to look up the DestinyActivityTypeDefinition for human readable info, but be forewarned: Playlists and many PVP Map Activities will map to generic Activity Types. You&#39;ll have to use your knowledge of the Activity Mode being played to get more specific information about what the user is playing.</value>
        [DataMember(Name="activityTypeHash", EmitDefaultValue=false)]
        public long ActivityTypeHash { get; set; }

        /// <summary>
        /// The difficulty tier of the activity.
        /// </summary>
        /// <value>The difficulty tier of the activity.</value>
        [DataMember(Name="tier", EmitDefaultValue=false)]
        public int Tier { get; set; }

        /// <summary>
        /// When Activities are completed, we generate a \&quot;Post-Game Carnage Report\&quot;, or PGCR, with details about what happened in that activity (how many kills someone got, which team won, etc...) We use this image as the background when displaying PGCR information, and often use it when we refer to the Activity in general.
        /// </summary>
        /// <value>When Activities are completed, we generate a \&quot;Post-Game Carnage Report\&quot;, or PGCR, with details about what happened in that activity (how many kills someone got, which team won, etc...) We use this image as the background when displaying PGCR information, and often use it when we refer to the Activity in general.</value>
        [DataMember(Name="pgcrImage", EmitDefaultValue=false)]
        public string PgcrImage { get; set; }

        /// <summary>
        /// The expected possible rewards for the activity. These rewards may or may not be accessible for an individual player based on their character state, the account state, and even the game&#39;s state overall. But it is a useful reference for possible rewards you can earn in the activity. These match up to rewards displayed when you hover over the Activity in the in-game Director, and often refer to Placeholder or \&quot;Dummy\&quot; items: items that tell you what you can earn in vague terms rather than what you&#39;ll specifically be earning (partly because the game doesn&#39;t even know what you&#39;ll earn specifically until you roll for it at the end)
        /// </summary>
        /// <value>The expected possible rewards for the activity. These rewards may or may not be accessible for an individual player based on their character state, the account state, and even the game&#39;s state overall. But it is a useful reference for possible rewards you can earn in the activity. These match up to rewards displayed when you hover over the Activity in the in-game Director, and often refer to Placeholder or \&quot;Dummy\&quot; items: items that tell you what you can earn in vague terms rather than what you&#39;ll specifically be earning (partly because the game doesn&#39;t even know what you&#39;ll earn specifically until you roll for it at the end)</value>
        [DataMember(Name="rewards", EmitDefaultValue=false)]
        public List<DestinyDefinitionsDestinyActivityRewardDefinition> Rewards { get; set; }

        /// <summary>
        /// Activities can have Modifiers, as defined in DestinyActivityModifierDefinition. These are references to the modifiers that *can* be applied to that activity, along with data that we use to determine if that modifier is actually active at any given point in time.
        /// </summary>
        /// <value>Activities can have Modifiers, as defined in DestinyActivityModifierDefinition. These are references to the modifiers that *can* be applied to that activity, along with data that we use to determine if that modifier is actually active at any given point in time.</value>
        [DataMember(Name="modifiers", EmitDefaultValue=false)]
        public List<DestinyDefinitionsDestinyActivityModifierReferenceDefinition> Modifiers { get; set; }

        /// <summary>
        /// If True, this Activity is actually a Playlist that refers to multiple possible specific Activities and Activity Modes. For instance, a Crucible Playlist may have references to multiple Activities (Maps) with multiple Activity Modes (specific PvP gameplay modes). If this is true, refer to the playlistItems property for the specific entries in the playlist.
        /// </summary>
        /// <value>If True, this Activity is actually a Playlist that refers to multiple possible specific Activities and Activity Modes. For instance, a Crucible Playlist may have references to multiple Activities (Maps) with multiple Activity Modes (specific PvP gameplay modes). If this is true, refer to the playlistItems property for the specific entries in the playlist.</value>
        [DataMember(Name="isPlaylist", EmitDefaultValue=false)]
        public bool IsPlaylist { get; set; }

        /// <summary>
        /// An activity can have many Challenges, of which any subset of them may be active for play at any given period of time. This gives the information about the challenges and data that we use to understand when they&#39;re active and what rewards they provide. Sadly, at the moment there&#39;s no central definition for challenges: much like \&quot;Skulls\&quot; were in Destiny 1, these are defined on individual activities and there can be many duplicates/near duplicates across the Destiny 2 ecosystem. I have it in mind to centralize these in a future revision of the API, but we are out of time.
        /// </summary>
        /// <value>An activity can have many Challenges, of which any subset of them may be active for play at any given period of time. This gives the information about the challenges and data that we use to understand when they&#39;re active and what rewards they provide. Sadly, at the moment there&#39;s no central definition for challenges: much like \&quot;Skulls\&quot; were in Destiny 1, these are defined on individual activities and there can be many duplicates/near duplicates across the Destiny 2 ecosystem. I have it in mind to centralize these in a future revision of the API, but we are out of time.</value>
        [DataMember(Name="challenges", EmitDefaultValue=false)]
        public List<DestinyDefinitionsDestinyActivityChallengeDefinition> Challenges { get; set; }

        /// <summary>
        /// If there are status strings related to the activity and based on internal state of the game, account, or character, then this will be the definition of those strings and the states needed in order for the strings to be shown.
        /// </summary>
        /// <value>If there are status strings related to the activity and based on internal state of the game, account, or character, then this will be the definition of those strings and the states needed in order for the strings to be shown.</value>
        [DataMember(Name="optionalUnlockStrings", EmitDefaultValue=false)]
        public List<DestinyDefinitionsDestinyActivityUnlockStringDefinition> OptionalUnlockStrings { get; set; }

        /// <summary>
        /// Represents all of the possible activities that could be played in the Playlist, along with information that we can use to determine if they are active at the present time.
        /// </summary>
        /// <value>Represents all of the possible activities that could be played in the Playlist, along with information that we can use to determine if they are active at the present time.</value>
        [DataMember(Name="playlistItems", EmitDefaultValue=false)]
        public List<DestinyDefinitionsDestinyActivityPlaylistItemDefinition> PlaylistItems { get; set; }

        /// <summary>
        /// Unfortunately, in practice this is almost never populated. In theory, this is supposed to tell which Activity Graph to show if you bring up the director while in this activity.
        /// </summary>
        /// <value>Unfortunately, in practice this is almost never populated. In theory, this is supposed to tell which Activity Graph to show if you bring up the director while in this activity.</value>
        [DataMember(Name="activityGraphList", EmitDefaultValue=false)]
        public List<DestinyDefinitionsDestinyActivityGraphListEntryDefinition> ActivityGraphList { get; set; }

        /// <summary>
        /// This block of data provides information about the Activity&#39;s matchmaking attributes: how many people can join and such.
        /// </summary>
        /// <value>This block of data provides information about the Activity&#39;s matchmaking attributes: how many people can join and such.</value>
        [DataMember(Name="matchmaking", EmitDefaultValue=false)]
        public DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition Matchmaking { get; set; }

        /// <summary>
        /// This block of data, if it exists, provides information about the guided game experience and restrictions for this activity. If it doesn&#39;t exist, the game is not able to be played as a guided game.
        /// </summary>
        /// <value>This block of data, if it exists, provides information about the guided game experience and restrictions for this activity. If it doesn&#39;t exist, the game is not able to be played as a guided game.</value>
        [DataMember(Name="guidedGame", EmitDefaultValue=false)]
        public DestinyDefinitionsDestinyActivityGuidedBlockDefinition GuidedGame { get; set; }

        /// <summary>
        /// If this activity had an activity mode directly defined on it, this will be the hash of that mode.
        /// </summary>
        /// <value>If this activity had an activity mode directly defined on it, this will be the hash of that mode.</value>
        [DataMember(Name="directActivityModeHash", EmitDefaultValue=false)]
        public long DirectActivityModeHash { get; set; }

        /// <summary>
        /// The set of all possible loadout requirements that could be active for this activity. Only one will be active at any given time, and you can discover which one through activity-associated data such as Milestones that have activity info on them.
        /// </summary>
        /// <value>The set of all possible loadout requirements that could be active for this activity. Only one will be active at any given time, and you can discover which one through activity-associated data such as Milestones that have activity info on them.</value>
        [DataMember(Name="loadouts", EmitDefaultValue=false)]
        public List<DestinyDefinitionsDestinyActivityLoadoutRequirementSet> Loadouts { get; set; }

        /// <summary>
        /// The hash identifiers for Activity Modes relevant to this activity.  Note that if this is a playlist, the specific playlist entry chosen will determine the actual activity modes that end up being relevant.
        /// </summary>
        /// <value>The hash identifiers for Activity Modes relevant to this activity.  Note that if this is a playlist, the specific playlist entry chosen will determine the actual activity modes that end up being relevant.</value>
        [DataMember(Name="activityModeHashes", EmitDefaultValue=false)]
        public List<long> ActivityModeHashes { get; set; }

        /// <summary>
        /// The activity modes - if any - in enum form. Because we can&#39;t seem to escape the enums.
        /// </summary>
        /// <value>The activity modes - if any - in enum form. Because we can&#39;t seem to escape the enums.</value>
        [DataMember(Name="activityModeTypes", EmitDefaultValue=false)]
        public List<int> ActivityModeTypes { get; set; }

        /// <summary>
        /// If true, this activity is a PVP activity or playlist.
        /// </summary>
        /// <value>If true, this activity is a PVP activity or playlist.</value>
        [DataMember(Name="isPvP", EmitDefaultValue=false)]
        public bool IsPvP { get; set; }

        /// <summary>
        /// The list of phases or points of entry into an activity, along with information we can use to determine their gating and availability.
        /// </summary>
        /// <value>The list of phases or points of entry into an activity, along with information we can use to determine their gating and availability.</value>
        [DataMember(Name="insertionPoints", EmitDefaultValue=false)]
        public List<DestinyDefinitionsDestinyActivityInsertionPointDefinition> InsertionPoints { get; set; }

        /// <summary>
        /// A list of location mappings that are affected by this activity. Pulled out of DestinyLocationDefinitions for our/your lookup convenience.
        /// </summary>
        /// <value>A list of location mappings that are affected by this activity. Pulled out of DestinyLocationDefinitions for our/your lookup convenience.</value>
        [DataMember(Name="activityLocationMappings", EmitDefaultValue=false)]
        public List<DestinyConstantsDestinyEnvironmentLocationMapping> ActivityLocationMappings { get; set; }

        /// <summary>
        /// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
        /// </summary>
        /// <value>The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.</value>
        [DataMember(Name="hash", EmitDefaultValue=false)]
        public long Hash { get; set; }

        /// <summary>
        /// The index of the entity as it was found in the investment tables.
        /// </summary>
        /// <value>The index of the entity as it was found in the investment tables.</value>
        [DataMember(Name="index", EmitDefaultValue=false)]
        public int Index { get; set; }

        /// <summary>
        /// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
        /// </summary>
        /// <value>If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!</value>
        [DataMember(Name="redacted", EmitDefaultValue=false)]
        public bool Redacted { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class DestinyDefinitionsDestinyActivityDefinition {\n");
            sb.Append("  DisplayProperties: ").Append(DisplayProperties).Append("\n");
            sb.Append("  OriginalDisplayProperties: ").Append(OriginalDisplayProperties).Append("\n");
            sb.Append("  SelectionScreenDisplayProperties: ").Append(SelectionScreenDisplayProperties).Append("\n");
            sb.Append("  ReleaseIcon: ").Append(ReleaseIcon).Append("\n");
            sb.Append("  ReleaseTime: ").Append(ReleaseTime).Append("\n");
            sb.Append("  ActivityLevel: ").Append(ActivityLevel).Append("\n");
            sb.Append("  ActivityLightLevel: ").Append(ActivityLightLevel).Append("\n");
            sb.Append("  DestinationHash: ").Append(DestinationHash).Append("\n");
            sb.Append("  PlaceHash: ").Append(PlaceHash).Append("\n");
            sb.Append("  ActivityTypeHash: ").Append(ActivityTypeHash).Append("\n");
            sb.Append("  Tier: ").Append(Tier).Append("\n");
            sb.Append("  PgcrImage: ").Append(PgcrImage).Append("\n");
            sb.Append("  Rewards: ").Append(Rewards).Append("\n");
            sb.Append("  Modifiers: ").Append(Modifiers).Append("\n");
            sb.Append("  IsPlaylist: ").Append(IsPlaylist).Append("\n");
            sb.Append("  Challenges: ").Append(Challenges).Append("\n");
            sb.Append("  OptionalUnlockStrings: ").Append(OptionalUnlockStrings).Append("\n");
            sb.Append("  PlaylistItems: ").Append(PlaylistItems).Append("\n");
            sb.Append("  ActivityGraphList: ").Append(ActivityGraphList).Append("\n");
            sb.Append("  Matchmaking: ").Append(Matchmaking).Append("\n");
            sb.Append("  GuidedGame: ").Append(GuidedGame).Append("\n");
            sb.Append("  DirectActivityModeHash: ").Append(DirectActivityModeHash).Append("\n");
            sb.Append("  DirectActivityModeType: ").Append(DirectActivityModeType).Append("\n");
            sb.Append("  Loadouts: ").Append(Loadouts).Append("\n");
            sb.Append("  ActivityModeHashes: ").Append(ActivityModeHashes).Append("\n");
            sb.Append("  ActivityModeTypes: ").Append(ActivityModeTypes).Append("\n");
            sb.Append("  IsPvP: ").Append(IsPvP).Append("\n");
            sb.Append("  InsertionPoints: ").Append(InsertionPoints).Append("\n");
            sb.Append("  ActivityLocationMappings: ").Append(ActivityLocationMappings).Append("\n");
            sb.Append("  Hash: ").Append(Hash).Append("\n");
            sb.Append("  Index: ").Append(Index).Append("\n");
            sb.Append("  Redacted: ").Append(Redacted).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DestinyDefinitionsDestinyActivityDefinition);
        }

        /// <summary>
        /// Returns true if DestinyDefinitionsDestinyActivityDefinition instances are equal
        /// </summary>
        /// <param name="input">Instance of DestinyDefinitionsDestinyActivityDefinition to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DestinyDefinitionsDestinyActivityDefinition input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.DisplayProperties == input.DisplayProperties ||
                    (this.DisplayProperties != null &&
                    this.DisplayProperties.Equals(input.DisplayProperties))
                ) && 
                (
                    this.OriginalDisplayProperties == input.OriginalDisplayProperties ||
                    (this.OriginalDisplayProperties != null &&
                    this.OriginalDisplayProperties.Equals(input.OriginalDisplayProperties))
                ) && 
                (
                    this.SelectionScreenDisplayProperties == input.SelectionScreenDisplayProperties ||
                    (this.SelectionScreenDisplayProperties != null &&
                    this.SelectionScreenDisplayProperties.Equals(input.SelectionScreenDisplayProperties))
                ) && 
                (
                    this.ReleaseIcon == input.ReleaseIcon ||
                    (this.ReleaseIcon != null &&
                    this.ReleaseIcon.Equals(input.ReleaseIcon))
                ) && 
                (
                    this.ReleaseTime == input.ReleaseTime ||
                    this.ReleaseTime.Equals(input.ReleaseTime)
                ) && 
                (
                    this.ActivityLevel == input.ActivityLevel ||
                    this.ActivityLevel.Equals(input.ActivityLevel)
                ) && 
                (
                    this.ActivityLightLevel == input.ActivityLightLevel ||
                    this.ActivityLightLevel.Equals(input.ActivityLightLevel)
                ) && 
                (
                    this.DestinationHash == input.DestinationHash ||
                    this.DestinationHash.Equals(input.DestinationHash)
                ) && 
                (
                    this.PlaceHash == input.PlaceHash ||
                    this.PlaceHash.Equals(input.PlaceHash)
                ) && 
                (
                    this.ActivityTypeHash == input.ActivityTypeHash ||
                    this.ActivityTypeHash.Equals(input.ActivityTypeHash)
                ) && 
                (
                    this.Tier == input.Tier ||
                    this.Tier.Equals(input.Tier)
                ) && 
                (
                    this.PgcrImage == input.PgcrImage ||
                    (this.PgcrImage != null &&
                    this.PgcrImage.Equals(input.PgcrImage))
                ) && 
                (
                    this.Rewards == input.Rewards ||
                    this.Rewards != null &&
                    input.Rewards != null &&
                    this.Rewards.SequenceEqual(input.Rewards)
                ) && 
                (
                    this.Modifiers == input.Modifiers ||
                    this.Modifiers != null &&
                    input.Modifiers != null &&
                    this.Modifiers.SequenceEqual(input.Modifiers)
                ) && 
                (
                    this.IsPlaylist == input.IsPlaylist ||
                    this.IsPlaylist.Equals(input.IsPlaylist)
                ) && 
                (
                    this.Challenges == input.Challenges ||
                    this.Challenges != null &&
                    input.Challenges != null &&
                    this.Challenges.SequenceEqual(input.Challenges)
                ) && 
                (
                    this.OptionalUnlockStrings == input.OptionalUnlockStrings ||
                    this.OptionalUnlockStrings != null &&
                    input.OptionalUnlockStrings != null &&
                    this.OptionalUnlockStrings.SequenceEqual(input.OptionalUnlockStrings)
                ) && 
                (
                    this.PlaylistItems == input.PlaylistItems ||
                    this.PlaylistItems != null &&
                    input.PlaylistItems != null &&
                    this.PlaylistItems.SequenceEqual(input.PlaylistItems)
                ) && 
                (
                    this.ActivityGraphList == input.ActivityGraphList ||
                    this.ActivityGraphList != null &&
                    input.ActivityGraphList != null &&
                    this.ActivityGraphList.SequenceEqual(input.ActivityGraphList)
                ) && 
                (
                    this.Matchmaking == input.Matchmaking ||
                    (this.Matchmaking != null &&
                    this.Matchmaking.Equals(input.Matchmaking))
                ) && 
                (
                    this.GuidedGame == input.GuidedGame ||
                    (this.GuidedGame != null &&
                    this.GuidedGame.Equals(input.GuidedGame))
                ) && 
                (
                    this.DirectActivityModeHash == input.DirectActivityModeHash ||
                    this.DirectActivityModeHash.Equals(input.DirectActivityModeHash)
                ) && 
                (
                    this.DirectActivityModeType == input.DirectActivityModeType ||
                    this.DirectActivityModeType.Equals(input.DirectActivityModeType)
                ) && 
                (
                    this.Loadouts == input.Loadouts ||
                    this.Loadouts != null &&
                    input.Loadouts != null &&
                    this.Loadouts.SequenceEqual(input.Loadouts)
                ) && 
                (
                    this.ActivityModeHashes == input.ActivityModeHashes ||
                    this.ActivityModeHashes != null &&
                    input.ActivityModeHashes != null &&
                    this.ActivityModeHashes.SequenceEqual(input.ActivityModeHashes)
                ) && 
                (
                    this.ActivityModeTypes == input.ActivityModeTypes ||
                    this.ActivityModeTypes != null &&
                    input.ActivityModeTypes != null &&
                    this.ActivityModeTypes.SequenceEqual(input.ActivityModeTypes)
                ) && 
                (
                    this.IsPvP == input.IsPvP ||
                    this.IsPvP.Equals(input.IsPvP)
                ) && 
                (
                    this.InsertionPoints == input.InsertionPoints ||
                    this.InsertionPoints != null &&
                    input.InsertionPoints != null &&
                    this.InsertionPoints.SequenceEqual(input.InsertionPoints)
                ) && 
                (
                    this.ActivityLocationMappings == input.ActivityLocationMappings ||
                    this.ActivityLocationMappings != null &&
                    input.ActivityLocationMappings != null &&
                    this.ActivityLocationMappings.SequenceEqual(input.ActivityLocationMappings)
                ) && 
                (
                    this.Hash == input.Hash ||
                    this.Hash.Equals(input.Hash)
                ) && 
                (
                    this.Index == input.Index ||
                    this.Index.Equals(input.Index)
                ) && 
                (
                    this.Redacted == input.Redacted ||
                    this.Redacted.Equals(input.Redacted)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.DisplayProperties != null)
                    hashCode = hashCode * 59 + this.DisplayProperties.GetHashCode();
                if (this.OriginalDisplayProperties != null)
                    hashCode = hashCode * 59 + this.OriginalDisplayProperties.GetHashCode();
                if (this.SelectionScreenDisplayProperties != null)
                    hashCode = hashCode * 59 + this.SelectionScreenDisplayProperties.GetHashCode();
                if (this.ReleaseIcon != null)
                    hashCode = hashCode * 59 + this.ReleaseIcon.GetHashCode();
                hashCode = hashCode * 59 + this.ReleaseTime.GetHashCode();
                hashCode = hashCode * 59 + this.ActivityLevel.GetHashCode();
                hashCode = hashCode * 59 + this.ActivityLightLevel.GetHashCode();
                hashCode = hashCode * 59 + this.DestinationHash.GetHashCode();
                hashCode = hashCode * 59 + this.PlaceHash.GetHashCode();
                hashCode = hashCode * 59 + this.ActivityTypeHash.GetHashCode();
                hashCode = hashCode * 59 + this.Tier.GetHashCode();
                if (this.PgcrImage != null)
                    hashCode = hashCode * 59 + this.PgcrImage.GetHashCode();
                if (this.Rewards != null)
                    hashCode = hashCode * 59 + this.Rewards.GetHashCode();
                if (this.Modifiers != null)
                    hashCode = hashCode * 59 + this.Modifiers.GetHashCode();
                hashCode = hashCode * 59 + this.IsPlaylist.GetHashCode();
                if (this.Challenges != null)
                    hashCode = hashCode * 59 + this.Challenges.GetHashCode();
                if (this.OptionalUnlockStrings != null)
                    hashCode = hashCode * 59 + this.OptionalUnlockStrings.GetHashCode();
                if (this.PlaylistItems != null)
                    hashCode = hashCode * 59 + this.PlaylistItems.GetHashCode();
                if (this.ActivityGraphList != null)
                    hashCode = hashCode * 59 + this.ActivityGraphList.GetHashCode();
                if (this.Matchmaking != null)
                    hashCode = hashCode * 59 + this.Matchmaking.GetHashCode();
                if (this.GuidedGame != null)
                    hashCode = hashCode * 59 + this.GuidedGame.GetHashCode();
                hashCode = hashCode * 59 + this.DirectActivityModeHash.GetHashCode();
                hashCode = hashCode * 59 + this.DirectActivityModeType.GetHashCode();
                if (this.Loadouts != null)
                    hashCode = hashCode * 59 + this.Loadouts.GetHashCode();
                if (this.ActivityModeHashes != null)
                    hashCode = hashCode * 59 + this.ActivityModeHashes.GetHashCode();
                if (this.ActivityModeTypes != null)
                    hashCode = hashCode * 59 + this.ActivityModeTypes.GetHashCode();
                hashCode = hashCode * 59 + this.IsPvP.GetHashCode();
                if (this.InsertionPoints != null)
                    hashCode = hashCode * 59 + this.InsertionPoints.GetHashCode();
                if (this.ActivityLocationMappings != null)
                    hashCode = hashCode * 59 + this.ActivityLocationMappings.GetHashCode();
                hashCode = hashCode * 59 + this.Hash.GetHashCode();
                hashCode = hashCode * 59 + this.Index.GetHashCode();
                hashCode = hashCode * 59 + this.Redacted.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
