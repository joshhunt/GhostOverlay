/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.8.0
 * Contact: support@bungie.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = BungieNetApi.Client.OpenAPIDateConverter;

namespace BungieNetApi.Model
{
    /// <summary>
    /// Information about the item&#39;s calculated stats, with as much data as we can find for the stats without having an actual instance of the item.  Note that this means the entire concept of providing these stats is fundamentally insufficient: we cannot predict with 100% accuracy the conditions under which an item can spawn, so we use various heuristics to attempt to simulate the conditions as accurately as possible. Actual stats for items in-game can and will vary, but these should at least be useful base points for comparison and display.  It is also worth noting that some stats, like Magazine size, have further calculations performed on them by scripts in-game and on the game servers that BNet does not have access to. We cannot know how those stats are further transformed, and thus some stats will be inaccurate even on instances of items in BNet vs. how they appear in-game. This is a known limitation of our item statistics, without any planned fix.
    /// </summary>
    [DataContract]
    public partial class DestinyDefinitionsDestinyItemStatBlockDefinition :  IEquatable<DestinyDefinitionsDestinyItemStatBlockDefinition>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DestinyDefinitionsDestinyItemStatBlockDefinition" /> class.
        /// </summary>
        /// <param name="disablePrimaryStatDisplay">If true, the game won&#39;t show the \&quot;primary\&quot; stat on this item when you inspect it.  NOTE: This is being manually mapped, because I happen to want it in a block that isn&#39;t going to directly create this derivative block..</param>
        /// <param name="statGroupHash">If the item&#39;s stats are meant to be modified by a DestinyStatGroupDefinition, this will be the identifier for that definition.  If you are using live data or precomputed stats data on the DestinyInventoryItemDefinition.stats.stats property, you don&#39;t have to worry about statGroupHash and how it alters stats: the already altered stats are provided to you. But if you want to see how the sausage gets made, or perform computations yourself, this is valuable information..</param>
        /// <param name="stats">If you are looking for precomputed values for the stats on a weapon, this is where they are stored. Technically these are the \&quot;Display\&quot; stat values. Please see DestinyStatsDefinition for what Display Stat Values means, it&#39;s a very long story... but essentially these are the closest values BNet can get to the item stats that you see in-game.  These stats are keyed by the DestinyStatDefinition&#39;s hash identifier for the stat that&#39;s found on the item..</param>
        /// <param name="hasDisplayableStats">A quick and lazy way to determine whether any stat other than the \&quot;primary\&quot; stat is actually visible on the item. Items often have stats that we return in case people find them useful, but they&#39;re not part of the \&quot;Stat Group\&quot; and thus we wouldn&#39;t display them in our UI. If this is False, then we&#39;re not going to display any of these stats other than the primary one..</param>
        /// <param name="primaryBaseStatHash">This stat is determined to be the \&quot;primary\&quot; stat, and can be looked up in the stats or any other stat collection related to the item.  Use this hash to look up the stat&#39;s value using DestinyInventoryItemDefinition.stats.stats, and the renderable data for the primary stat in the related DestinyStatDefinition..</param>
        public DestinyDefinitionsDestinyItemStatBlockDefinition(bool disablePrimaryStatDisplay = default(bool), long statGroupHash = default(long), Dictionary<string, DestinyDefinitionsDestinyInventoryItemStatDefinition> stats = default(Dictionary<string, DestinyDefinitionsDestinyInventoryItemStatDefinition>), bool hasDisplayableStats = default(bool), long primaryBaseStatHash = default(long))
        {
            this.DisablePrimaryStatDisplay = disablePrimaryStatDisplay;
            this.StatGroupHash = statGroupHash;
            this.Stats = stats;
            this.HasDisplayableStats = hasDisplayableStats;
            this.PrimaryBaseStatHash = primaryBaseStatHash;
        }
        
        /// <summary>
        /// If true, the game won&#39;t show the \&quot;primary\&quot; stat on this item when you inspect it.  NOTE: This is being manually mapped, because I happen to want it in a block that isn&#39;t going to directly create this derivative block.
        /// </summary>
        /// <value>If true, the game won&#39;t show the \&quot;primary\&quot; stat on this item when you inspect it.  NOTE: This is being manually mapped, because I happen to want it in a block that isn&#39;t going to directly create this derivative block.</value>
        [DataMember(Name="disablePrimaryStatDisplay", EmitDefaultValue=false)]
        public bool DisablePrimaryStatDisplay { get; set; }

        /// <summary>
        /// If the item&#39;s stats are meant to be modified by a DestinyStatGroupDefinition, this will be the identifier for that definition.  If you are using live data or precomputed stats data on the DestinyInventoryItemDefinition.stats.stats property, you don&#39;t have to worry about statGroupHash and how it alters stats: the already altered stats are provided to you. But if you want to see how the sausage gets made, or perform computations yourself, this is valuable information.
        /// </summary>
        /// <value>If the item&#39;s stats are meant to be modified by a DestinyStatGroupDefinition, this will be the identifier for that definition.  If you are using live data or precomputed stats data on the DestinyInventoryItemDefinition.stats.stats property, you don&#39;t have to worry about statGroupHash and how it alters stats: the already altered stats are provided to you. But if you want to see how the sausage gets made, or perform computations yourself, this is valuable information.</value>
        [DataMember(Name="statGroupHash", EmitDefaultValue=false)]
        public long StatGroupHash { get; set; }

        /// <summary>
        /// If you are looking for precomputed values for the stats on a weapon, this is where they are stored. Technically these are the \&quot;Display\&quot; stat values. Please see DestinyStatsDefinition for what Display Stat Values means, it&#39;s a very long story... but essentially these are the closest values BNet can get to the item stats that you see in-game.  These stats are keyed by the DestinyStatDefinition&#39;s hash identifier for the stat that&#39;s found on the item.
        /// </summary>
        /// <value>If you are looking for precomputed values for the stats on a weapon, this is where they are stored. Technically these are the \&quot;Display\&quot; stat values. Please see DestinyStatsDefinition for what Display Stat Values means, it&#39;s a very long story... but essentially these are the closest values BNet can get to the item stats that you see in-game.  These stats are keyed by the DestinyStatDefinition&#39;s hash identifier for the stat that&#39;s found on the item.</value>
        [DataMember(Name="stats", EmitDefaultValue=false)]
        public Dictionary<string, DestinyDefinitionsDestinyInventoryItemStatDefinition> Stats { get; set; }

        /// <summary>
        /// A quick and lazy way to determine whether any stat other than the \&quot;primary\&quot; stat is actually visible on the item. Items often have stats that we return in case people find them useful, but they&#39;re not part of the \&quot;Stat Group\&quot; and thus we wouldn&#39;t display them in our UI. If this is False, then we&#39;re not going to display any of these stats other than the primary one.
        /// </summary>
        /// <value>A quick and lazy way to determine whether any stat other than the \&quot;primary\&quot; stat is actually visible on the item. Items often have stats that we return in case people find them useful, but they&#39;re not part of the \&quot;Stat Group\&quot; and thus we wouldn&#39;t display them in our UI. If this is False, then we&#39;re not going to display any of these stats other than the primary one.</value>
        [DataMember(Name="hasDisplayableStats", EmitDefaultValue=false)]
        public bool HasDisplayableStats { get; set; }

        /// <summary>
        /// This stat is determined to be the \&quot;primary\&quot; stat, and can be looked up in the stats or any other stat collection related to the item.  Use this hash to look up the stat&#39;s value using DestinyInventoryItemDefinition.stats.stats, and the renderable data for the primary stat in the related DestinyStatDefinition.
        /// </summary>
        /// <value>This stat is determined to be the \&quot;primary\&quot; stat, and can be looked up in the stats or any other stat collection related to the item.  Use this hash to look up the stat&#39;s value using DestinyInventoryItemDefinition.stats.stats, and the renderable data for the primary stat in the related DestinyStatDefinition.</value>
        [DataMember(Name="primaryBaseStatHash", EmitDefaultValue=false)]
        public long PrimaryBaseStatHash { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class DestinyDefinitionsDestinyItemStatBlockDefinition {\n");
            sb.Append("  DisablePrimaryStatDisplay: ").Append(DisablePrimaryStatDisplay).Append("\n");
            sb.Append("  StatGroupHash: ").Append(StatGroupHash).Append("\n");
            sb.Append("  Stats: ").Append(Stats).Append("\n");
            sb.Append("  HasDisplayableStats: ").Append(HasDisplayableStats).Append("\n");
            sb.Append("  PrimaryBaseStatHash: ").Append(PrimaryBaseStatHash).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DestinyDefinitionsDestinyItemStatBlockDefinition);
        }

        /// <summary>
        /// Returns true if DestinyDefinitionsDestinyItemStatBlockDefinition instances are equal
        /// </summary>
        /// <param name="input">Instance of DestinyDefinitionsDestinyItemStatBlockDefinition to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DestinyDefinitionsDestinyItemStatBlockDefinition input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.DisablePrimaryStatDisplay == input.DisablePrimaryStatDisplay ||
                    this.DisablePrimaryStatDisplay.Equals(input.DisablePrimaryStatDisplay)
                ) && 
                (
                    this.StatGroupHash == input.StatGroupHash ||
                    this.StatGroupHash.Equals(input.StatGroupHash)
                ) && 
                (
                    this.Stats == input.Stats ||
                    this.Stats != null &&
                    input.Stats != null &&
                    this.Stats.SequenceEqual(input.Stats)
                ) && 
                (
                    this.HasDisplayableStats == input.HasDisplayableStats ||
                    this.HasDisplayableStats.Equals(input.HasDisplayableStats)
                ) && 
                (
                    this.PrimaryBaseStatHash == input.PrimaryBaseStatHash ||
                    this.PrimaryBaseStatHash.Equals(input.PrimaryBaseStatHash)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = hashCode * 59 + this.DisablePrimaryStatDisplay.GetHashCode();
                hashCode = hashCode * 59 + this.StatGroupHash.GetHashCode();
                if (this.Stats != null)
                    hashCode = hashCode * 59 + this.Stats.GetHashCode();
                hashCode = hashCode * 59 + this.HasDisplayableStats.GetHashCode();
                hashCode = hashCode * 59 + this.PrimaryBaseStatHash.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
